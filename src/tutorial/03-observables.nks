
<p>
  Observables are at the very core of Domic and are the foundation
  of its dynamic nature.
</p>

<h3>Creating an Observable</h3>

<div class='row'>
  <div>
    <p>
      When creating an observable, you always must give a value. Most of the
      time, this value will be enough for typescript to guess what kind of
      Observable you're dealing with.
    </p>

    <p>While you can use <code>new Observable(...)</code> to create an observable,
      the <code>o(/* value */)</code> function shorthand is actually preferred.
    </p>

  </div>

  <textarea class='editor'>{% filter escape %}
var ob = new Observable(4) // Observable<number>
var ob2 = new Observable('hello') // Observable<string>

// As a shorthand, use the o() function
var ob3 = o(false) // Observable<boolean>
var ob4 = o([] as string[]) // Observable<string[]>
  {%- endfilter -%}</textarea>
</div>

<h3>Getting and setting its value</h3>

<div class='row'>
  <div>
    <p>
      Unlike other libraries such as RxJS, domic's observables always
      have a value that you can get with the <code>get()</code> method.
    </p>
    <p>
      To set its value, simply use the <code>set()</code> method.
    </p>
  </div>

<textarea class='editor'>{% filter escape -%}
var a = new Observable(3)
var b = a.get() // 3
a.set(42)
var c = a.get() // 42
{%- endfilter -%}</textarea>
</div>

<div class='row'>
  <div>
    <p>
      Observables are generically typed to prevent a wrong data flow in your application.
    </p>
    <p>
      Since domic is built with typescript's strict flags, <code>null</code> and <code>undefined</code>
      are also checked.
    </p>
  </div>

<textarea class='editor'>{% filter escape -%}
var a = o(1) // a is Observable<number>
a.set('hello') // Error !
a.set(null) // Error !
a.set(4) // OK

var b = o(1 as number | null) // b is Observable<number|null>
b.set(null) // OK
{%- endfilter -%}</textarea>
</div>

<h3>Observing value changes</h3>

<p>FIXME: talk about the fact that there is an underlying notify() method
  and as such changes may not always be what we expect of them.</p>

<p>CAUTION: careful with the underlying value, we can lose updates
  if we're using two different Observables on the same underlying value.</p>

<p>Memory leaks !</p>

<h3>Using it with TSX</h3>

<div class='row'>
  <div>
    <p>
      Observables can be used as children of tsx code. Any change to them
      and their value will automatically be updated into the DOM.
    </p>

    <p>
      Note however that for this to work, <em>mounting</em> needs to be setup
      as per the instructions in the previous chapter.
    </p>
  </div>

<textarea class='editor'>{% filter escape -%}
var obs = o('some content')
document.appendChild(<h3>{obs}</h3>)

// At some point later...
obs.set('some other content')
{%- endfilter -%}</textarea>
</div>


<div class='row'>
  <div>
    <p>Similarily, node attributes can also be observables and updated
      whenever one changes.
    </p>

    <p>This example shows the class attribute being linked to an observable.
      While this will work as intended, read the chapter about special attributes,
      as the behaviour for class is actually more complex than just using strings.
    </p>
  </div>

<textarea class='editor'>{% filter escape -%}
var obs = o('myclass')
document.appendChild(<h3 class={obs}>My Title</h3>)

// At some point later...
obs.set('myotherclass')
{%- endfilter -%}</textarea>
</div>

<h3>The MaybeObservable type</h3>

<h3>Observing a property in a complex object</h3>

<h3>Working with arrays</h3>

<p>Observables can do a lot more than what was shown here and will be talked about
  some more in a later chapter.</p>